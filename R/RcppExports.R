# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The Flapjack algorithm
#'
#' Input: n-by-n cost matrix C
#'
#' @export
Flapjack <- function(C) {
    .Call('_wassersteinbound_Flapjack', PACKAGE = 'wassersteinbound', C)
}

#' @export
SimulateGibbs_ar1 <- function(x0, sd, c, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateGibbs_ar1', PACKAGE = 'wassersteinbound', x0, sd, c, iter_store_x, iter_final_x, thin)
}

#' @export
SimulateReflMaxGibbs_ar1 <- function(x0, y0, sd, c, L, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateReflMaxGibbs_ar1', PACKAGE = 'wassersteinbound', x0, y0, sd, c, L, iter_store_x, iter_final_x, thin)
}

#' @export
EvaluateJackknife1d <- function(x_sorted, y_sorted, inv_order_x, inv_order_y) {
    .Call('_wassersteinbound_EvaluateJackknife1d', PACKAGE = 'wassersteinbound', x_sorted, y_sorted, inv_order_x, inv_order_y)
}

#' @export
RWMLogistic <- function(x0, h, iter) {
    .Call('_wassersteinbound_RWMLogistic', PACKAGE = 'wassersteinbound', x0, h, iter)
}

#' @export
MALALogistic <- function(x0, h, iter) {
    .Call('_wassersteinbound_MALALogistic', PACKAGE = 'wassersteinbound', x0, h, iter)
}

#' @export
SimulateULA_scaling <- function(Sigma_inv, U, disp, h, iter, thin) {
    .Call('_wassersteinbound_SimulateULA_scaling', PACKAGE = 'wassersteinbound', Sigma_inv, U, disp, h, iter, thin)
}

#' @export
SimulateMALA_scaling <- function(Sigma_inv, U, disp, h, iter, thin) {
    .Call('_wassersteinbound_SimulateMALA_scaling', PACKAGE = 'wassersteinbound', Sigma_inv, U, disp, h, iter, thin)
}

#' @export
SimulateReflMaxULA_scaling <- function(Sigma_inv, U, disp, h, L, iter, iter_reference, thin) {
    .Call('_wassersteinbound_SimulateReflMaxULA_scaling', PACKAGE = 'wassersteinbound', Sigma_inv, U, disp, h, L, iter, iter_reference, thin)
}

#' @export
SimulateReflMaxMALA_scaling <- function(Sigma_inv, U, disp, h, L, iter, iter_reference, thin) {
    .Call('_wassersteinbound_SimulateReflMaxMALA_scaling', PACKAGE = 'wassersteinbound', Sigma_inv, U, disp, h, L, iter, iter_reference, thin)
}

#' @export
RWMMixture1d <- function(x0, p, mu, sigma, h, iter) {
    .Call('_wassersteinbound_RWMMixture1d', PACKAGE = 'wassersteinbound', x0, p, mu, sigma, h, iter)
}

#' @export
MALAMixture1d <- function(x0, p, mu, sigma, h, iter) {
    .Call('_wassersteinbound_MALAMixture1d', PACKAGE = 'wassersteinbound', x0, p, mu, sigma, h, iter)
}

#' Solve the assignment problem using the network simplex from Bonneel et al, 2011
#'
#' Input: n-by-n cost matrix C. 
#'
#' @export
SolveAssignmentNetworkflow <- function(C) {
    .Call('_wassersteinbound_SolveAssignmentNetworkflow', PACKAGE = 'wassersteinbound', C)
}

#' @export
SetSeed_cpp <- function(seed, stream = 0L) {
    invisible(.Call('_wassersteinbound_SetSeed_cpp', PACKAGE = 'wassersteinbound', seed, stream))
}

#' @export
EvaluateSquaredCost <- function(x, y, nthreads = 1L) {
    .Call('_wassersteinbound_EvaluateSquaredCost', PACKAGE = 'wassersteinbound', x, y, nthreads)
}

#' @export
RWMStdGaussian <- function(x0, h, iter) {
    .Call('_wassersteinbound_RWMStdGaussian', PACKAGE = 'wassersteinbound', x0, h, iter)
}

#' @export
MALAStdGaussian <- function(x0, h, iter) {
    .Call('_wassersteinbound_MALAStdGaussian', PACKAGE = 'wassersteinbound', x0, h, iter)
}

#' @export
SampleLatentVariables <- function(T, sig, phi) {
    .Call('_wassersteinbound_SampleLatentVariables', PACKAGE = 'wassersteinbound', T, sig, phi)
}

#' @export
SimulateRWM_SVM <- function(x0, y, beta, sigma, phi, h, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateRWM_SVM', PACKAGE = 'wassersteinbound', x0, y, beta, sigma, phi, h, iter_store_x, iter_final_x, thin)
}

#' @export
SimulateReflMaxRWM_SVM <- function(x0, y0, y_data, beta, sigma, phi, h, L, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateReflMaxRWM_SVM', PACKAGE = 'wassersteinbound', x0, y0, y_data, beta, sigma, phi, h, L, iter_store_x, iter_final_x, thin)
}

#' @export
SimulateMALA_SVM <- function(x0, y, beta, sigma, phi, h, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateMALA_SVM', PACKAGE = 'wassersteinbound', x0, y, beta, sigma, phi, h, iter_store_x, iter_final_x, thin)
}

#' @export
SimulateReflMaxMALA_SVM <- function(x0, y0, y_data, beta, sigma, phi, h, L, iter_store_x, iter_final_x, thin) {
    .Call('_wassersteinbound_SimulateReflMaxMALA_SVM', PACKAGE = 'wassersteinbound', x0, y0, y_data, beta, sigma, phi, h, L, iter_store_x, iter_final_x, thin)
}

#' @export
SimulateReflMaxRWMMeetingTime_SVM <- function(x0, y0, y_data, beta, sigma, phi, h, L, maxiter) {
    .Call('_wassersteinbound_SimulateReflMaxRWMMeetingTime_SVM', PACKAGE = 'wassersteinbound', x0, y0, y_data, beta, sigma, phi, h, L, maxiter)
}

#' @export
SimulateReflMaxMALAMeetingTime_SVM <- function(x0, y0, y_data, beta, sigma, phi, h, L) {
    .Call('_wassersteinbound_SimulateReflMaxMALAMeetingTime_SVM', PACKAGE = 'wassersteinbound', x0, y0, y_data, beta, sigma, phi, h, L)
}

#' @export
EvaluateW2sq <- function(a, A, b, B) {
    .Call('_wassersteinbound_EvaluateW2sq', PACKAGE = 'wassersteinbound', a, A, b, B)
}

#' @export
EvaluateW2sqGibbs <- function(mu_0, Sigma_0, mu, Sigma, iter, thin = 1L) {
    .Call('_wassersteinbound_EvaluateW2sqGibbs', PACKAGE = 'wassersteinbound', mu_0, Sigma_0, mu, Sigma, iter, thin)
}

#' @export
EvaluateW2sqGibbsFull <- function(mu_0, Sigma_0, mu, Sigma, iter, thin = 1L, nthreads = 1L) {
    .Call('_wassersteinbound_EvaluateW2sqGibbsFull', PACKAGE = 'wassersteinbound', mu_0, Sigma_0, mu, Sigma, iter, thin, nthreads)
}

#' @export
EvaluateW2sqULA <- function(mu_0, Sigma_0, mu, Sigma_ULA, M, which_iters, h) {
    .Call('_wassersteinbound_EvaluateW2sqULA', PACKAGE = 'wassersteinbound', mu_0, Sigma_0, mu, Sigma_ULA, M, which_iters, h)
}


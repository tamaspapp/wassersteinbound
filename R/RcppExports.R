# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Solve the assignment problem using TOMS1015, Guthe and Thuerck (2021)
#'
#' Input: n-by-d empirical measures x and y.
#'
#' @export
assignment_squared_euclidean_toms1015_cpp <- function(x, y, estimate_epsilon = TRUE) {
    .Call('_wassersteinbound_assignment_squared_euclidean_toms1015_cpp', PACKAGE = 'wassersteinbound', x, y, estimate_epsilon)
}

#' Solve the assignment problem using the network simplex from Bonneel et al. (2011)
#'
#' Input: n-by-d empirical measures x and y.
#'
#' @export
assignment_squared_euclidean_networkflow_cpp <- function(x, y, compute_assignment = FALSE) {
    .Call('_wassersteinbound_assignment_squared_euclidean_networkflow_cpp', PACKAGE = 'wassersteinbound', x, y, compute_assignment)
}

#' Solve the assignment problem using TOMS1015, Guthe and Thuerck (2021), then obtain the jackknife assignment costs using the "vanilla" Jonker-Volgenant algorithm
#'
#' Input: n-by-d empirical measures x and y.
#'
#' @export
assignment_squared_euclidean_jackknife_cpp <- function(x, y, estimate_epsilon = TRUE) {
    .Call('_wassersteinbound_assignment_squared_euclidean_jackknife_cpp', PACKAGE = 'wassersteinbound', x, y, estimate_epsilon)
}

#' @export
assignment_squared_euclidean_jackknife_1d_cpp <- function(x_sorted, y_sorted, inv_order_x, inv_order_y) {
    .Call('_wassersteinbound_assignment_squared_euclidean_jackknife_1d_cpp', PACKAGE = 'wassersteinbound', x_sorted, y_sorted, inv_order_x, inv_order_y)
}

#' Evaluate squared Euclidean cost matrix.
#'      Input is assumed to be in row-major format ("n" times "d").
#'
#' @export
EvaluateSquaredCost <- function(x, y) {
    .Call('_wassersteinbound_EvaluateSquaredCost', PACKAGE = 'wassersteinbound', x, y)
}

#' @export
gibbs_periodicAR1_cpp <- function(x0, sd, c, iter, thin) {
    .Call('_wassersteinbound_gibbs_periodicAR1_cpp', PACKAGE = 'wassersteinbound', x0, sd, c, iter, thin)
}

#' @export
gibbs_periodicAR1_CRN_cpp <- function(x0, y0, sd, c, iter, thin) {
    .Call('_wassersteinbound_gibbs_periodicAR1_CRN_cpp', PACKAGE = 'wassersteinbound', x0, y0, sd, c, iter, thin)
}

#' @export
gibbs_periodicAR1_ReflMax_cpp <- function(x0, y0, sd, c, iter, thin) {
    .Call('_wassersteinbound_gibbs_periodicAR1_ReflMax_cpp', PACKAGE = 'wassersteinbound', x0, y0, sd, c, iter, thin)
}

#' @export
low_inc_gamma_cpp <- function(rate, upper_truncation) {
    .Call('_wassersteinbound_low_inc_gamma_cpp', PACKAGE = 'wassersteinbound', rate, upper_truncation)
}

#' @export
low_inc_gamma_inv_cpp <- function(rate, p) {
    .Call('_wassersteinbound_low_inc_gamma_inv_cpp', PACKAGE = 'wassersteinbound', rate, p)
}

#' @export
cpp_prod <- function(X, Y) {
    .Call('_wassersteinbound_cpp_prod', PACKAGE = 'wassersteinbound', X, Y)
}

#' @export
cpp_crossprod <- function(X) {
    .Call('_wassersteinbound_cpp_crossprod', PACKAGE = 'wassersteinbound', X)
}

#' @export
cpp_cov <- function(X) {
    .Call('_wassersteinbound_cpp_cov', PACKAGE = 'wassersteinbound', X)
}

#' Re-Seed RNG from R
#'
#' @export
SetSeed_pcg32 <- function(seed, stream = 0L) {
    invisible(.Call('_wassersteinbound_SetSeed_pcg32', PACKAGE = 'wassersteinbound', seed, stream))
}

#' @export
rwm_cpp <- function(target_params, sampler_params, theta0, iter, thin) {
    .Call('_wassersteinbound_rwm_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, theta0, iter, thin)
}

#' @export
mala_cpp <- function(target_params, sampler_params, theta0, iter, thin) {
    .Call('_wassersteinbound_mala_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, theta0, iter, thin)
}

#' @export
ula_cpp <- function(target_params, sampler_params, theta0, iter, thin) {
    .Call('_wassersteinbound_ula_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, theta0, iter, thin)
}

#' @export
obab_cpp <- function(target_params, sampler_params, x0, iter, thin) {
    .Call('_wassersteinbound_obab_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, iter, thin)
}

#' @export
horowitz_cpp <- function(target_params, sampler_params, x0, iter, thin) {
    .Call('_wassersteinbound_horowitz_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, iter, thin)
}

#' @export
fisher_mala_cpp <- function(target_params, sampler_params, x0, iter, thin) {
    .Call('_wassersteinbound_fisher_mala_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, iter, thin)
}

#' @export
rwm_twoscalegcrn_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_rwm_twoscalegcrn_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
ula_twoscalecrn_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_ula_twoscalecrn_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
mala_twoscalecrn_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_mala_twoscalecrn_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
horowitz_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_horowitz_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
obab_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_obab_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
ula_mala_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_ula_mala_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
obab_horowitz_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_obab_horowitz_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
mala_CRN_2targets_cpp <- function(target_x_params, target_y_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_mala_CRN_2targets_cpp', PACKAGE = 'wassersteinbound', target_x_params, target_y_params, sampler_params, x0, y0, iter, thin)
}

#' SGLD: Stochastic gradient Langevin dynamics
#'
#' At each iteration, batches of "batch_size" are sampled uniformly without replacement. The draws are independent across iterations, i.e. we don't enforce "epochs" where we cycle over the whole dataset.
#'
#' @export
sgld_cpp <- function(target_params, sampler_params, theta0, iter, thin) {
    .Call('_wassersteinbound_sgld_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, theta0, iter, thin)
}

#' SGLD-CV: Stochastic gradient Langevin dynamics, with control variates.
#'
#' At each iteration, batches of "batch_size" are sampled uniformly without replacement. The draws are independent across iterations, i.e. we don't enforce "epochs" where we cycle over the whole dataset.
#'
#' @export
sgldcv_cpp <- function(target_params, sampler_params, theta0, iter, thin) {
    .Call('_wassersteinbound_sgldcv_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, theta0, iter, thin)
}

#' SGLD coupled with MALA (with exact gradient), CRN coupling.
#'
#' At each iteration of SGLD, batches of "batch_size" are sampled uniformly without replacement. The draws are independent across iterations, i.e. we don't enforce "epochs" where we cycle over the whole dataset.
#'
#' @export
sgld_mala_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_sgld_mala_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' SGLD-CV coupled with MALA (with exact gradient), CRN coupling.
#'
#' At each iteration of SGLD, batches of "batch_size" are sampled uniformly without replacement. The draws are independent across iterations, i.e. we don't enforce "epochs" where we cycle over the whole dataset.
#'
#' @export
sgldcv_mala_CRN_cpp <- function(target_params, sampler_params, x0, y0, iter, thin) {
    .Call('_wassersteinbound_sgldcv_mala_CRN_cpp', PACKAGE = 'wassersteinbound', target_params, sampler_params, x0, y0, iter, thin)
}

#' @export
potential_cpp <- function(target_params, theta) {
    .Call('_wassersteinbound_potential_cpp', PACKAGE = 'wassersteinbound', target_params, theta)
}

#' @export
gradpotential_cpp <- function(target_params, theta) {
    .Call('_wassersteinbound_gradpotential_cpp', PACKAGE = 'wassersteinbound', target_params, theta)
}

#' @export
hesspotential_cpp <- function(target_params, theta) {
    .Call('_wassersteinbound_hesspotential_cpp', PACKAGE = 'wassersteinbound', target_params, theta)
}

#' Compute 1D optimal transport cost and dual solution from sorted (equal-size) vectors of samples
#'
#' The optimal dual solution is recovered by sorting the two samples, then applying  Algorithm 3 of 
#' https://proceedings.mlr.press/v151/sejourne22a/sejourne22a.pdf, which simplifies considerably in our case.
#' (There are typos in the paper: line 4 of Algorithm 3 should be "a <= b"; the initialization should be g_1 = C(x_1, y_1).
#' See https://github.com/thibsej/fast_uot/blob/main/fastuot/uot1d.py for a correct implementation.)
#' 
#' @export
w2sq_1d_dual_cpp <- function(x_sorted, y_sorted) {
    .Call('_wassersteinbound_w2sq_1d_dual_cpp', PACKAGE = 'wassersteinbound', x_sorted, y_sorted)
}

#' @export
matrix_power_cpp <- function(A, n) {
    .Call('_wassersteinbound_matrix_power_cpp', PACKAGE = 'wassersteinbound', A, n)
}

#' Evaluate W_2^2 (w/ Euclidean norm) between two multivariate Gaussians N(a, A) and N(b, B). 
#'
#' @export
w2sq_gaussian_cpp <- function(a, A, b, B) {
    .Call('_wassersteinbound_w2sq_gaussian_cpp', PACKAGE = 'wassersteinbound', a, A, b, B)
}

#' Evaluate W_2^2 (w/ Euclidean norm) between first d-dimensions of marginal N(mu_t[1:d], Sigma_t[1:d]) and target N(mu[1:d], Sigma[1:d])
#' of a process obeying the autoregression:
#'              (mu_{t + 1} - mu_inf) = B (mu_t - mu_inf)
#'              (Sigma_{t + 1} - Sigma_inf) = B (Sigma_t - Sigma_inf) B.transpose()
#'
#' Any vector autoregressive process with "slope" B satisfies this recurrence relation as soon as the spectrum of B is inside the ball of radius 1.
#'
#' Deterministic Gibbs, ULA and OBAB all fall under this category.
#'
#' @export
w2sq_convergence_gaussian_recursive_cpp <- function(mu_0, Sigma_0, mu_inf, Sigma_inf, B, d, iter, thin, tol = 1e-12) {
    .Call('_wassersteinbound_w2sq_convergence_gaussian_recursive_cpp', PACKAGE = 'wassersteinbound', mu_0, Sigma_0, mu_inf, Sigma_inf, B, d, iter, thin, tol)
}

#'@export
colwise_rank_cpp <- function(mat) {
    .Call('_wassersteinbound_colwise_rank_cpp', PACKAGE = 'wassersteinbound', mat)
}

#'@export
permute_matrix_colwise_inplace_cpp <- function(mat, idx_colwise) {
    invisible(.Call('_wassersteinbound_permute_matrix_colwise_inplace_cpp', PACKAGE = 'wassersteinbound', mat, idx_colwise))
}

#'@export
colwise_squared_norm_with_skip_cpp <- function(x, y, rm_idx_x, rm_idx_y) {
    .Call('_wassersteinbound_colwise_squared_norm_with_skip_cpp', PACKAGE = 'wassersteinbound', x, y, rm_idx_x, rm_idx_y)
}

